package uq.deco2800.pyramidscheme.animations;

import uq.deco2800.pyramidscheme.animations.emitter.Emitter;
import uq.deco2800.pyramidscheme.cards.supercards.Card;
import uq.deco2800.pyramidscheme.cards.supercards.CardHiddenState;
import uq.deco2800.pyramidscheme.game.GameState;
import uq.deco2800.pyramidscheme.match.MatchCard;
import uq.deco2800.pyramidscheme.pyramid.PyramidCard;

import java.util.List;

/**
 * Created by nick on 11/09/2016.
 * <p>
 * The UserAnimations class extends the Animations class and handles all
 * the user(s) animations. Any animation which is generated by the user is created
 * through the methods used within this class and then subsequently added to the animations
 * queue to be called in the correct sequence of animations.
 */
public class UserAnimations extends Animations {

    public UserAnimations(GameState gs, AnimationCallback callback) {
        super(gs, callback);
    }

    /**
     * Triggers pyramid refill if the player runs out of cards.
     */
    public void animatePyramidRefill() {
        // Animate refill with parameter isUser == true
        int size = gs.getUserPyramid().getPyramidType().getSize();
        animatePyramidRefill(size, true);
    }

    /**
     * Takes the cards in cardList and passes them through flipCard method in animations.
     *
     * @param cardList List of pyramid cards to be flipped.
     */
    public void flipCards(List<PyramidCard> cardList) {
        for (PyramidCard c : cardList) {
            flipCard(c.getCard().get(), CardHiddenState.USERHIDDEN, CardHiddenState.VISIBLE, USER_PYRAMID_FLIP);
        }
    }

    /**
     * Sets the center of the card to the origin of particles to be emitted and emits on
     * that point.
     *
     * @param emitter the type of emit to be used on card
     * @param card    to have particles emitted off
     */
    public void emit(Emitter emitter, MatchCard card) {
        //Center on card
        double x = card.getX() + (Card.getCardWidth() / 2);
        double y = card.getY() + (Card.getCardHeight() / 2);

        // Emit on that point
        if (emitter != null && emitter.isEmitter()) {
            gs.addParticles(emitter.emit(x, y));
        }
    }

}
